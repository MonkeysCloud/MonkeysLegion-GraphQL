<?php declare(strict_types=1);

namespace MonkeysLegion\GraphQL\Command;

use MonkeysLegion\Cli\Console\Attributes\Command as CommandAttr;
use MonkeysLegion\Cli\Console\Command;
use MonkeysLegion\GraphQL\Scanner\EntityTypeMapper;

/**
 * Scaffolds a GraphQL Type class from a MonkeysLegion entity.
 *
 * Reads the entity's properties (via EntityTypeMapper) and generates
 * a ready-to-use Type class with #[Field] methods for each mapped field.
 *
 * Usage:
 *   php ml graphql:generate:type App\Entity\Product
 *   php ml graphql:generate:type App\Entity\Product --output=app/GraphQL/Type/ProductType.php
 */
#[CommandAttr('graphql:generate:type', 'Generate a GraphQL Type class from an entity')]
final class GenerateTypeCommand extends Command
{
    public function __construct(
        private readonly EntityTypeMapper $mapper,
    ) {
        parent::__construct();
    }

    protected function handle(): int
    {
        $entityClass = $this->argument(0);

        if ($entityClass === null || $entityClass === '') {
            $this->error('Usage: php ml graphql:generate:type <EntityClass>');
            $this->error('  Example: php ml graphql:generate:type App\\Entity\\Product');
            return self::FAILURE;
        }

        if (!class_exists($entityClass)) {
            $this->error("Entity class not found: {$entityClass}");
            return self::FAILURE;
        }

        try {
            $this->info("Scanning entity: {$entityClass}");

            $mapping = $this->mapper->map($entityClass);
            $entityName = $mapping['name'];
            $fields = $mapping['fields'];

            if ($fields === []) {
                $this->error("No mappable fields found in {$entityClass}.");
                $this->error('Ensure the entity has typed public properties or properties with #[Column]/#[Id] attributes.');
                return self::FAILURE;
            }

            $typeName = $entityName . 'Type';
            $code = $this->generateTypeClass($entityClass, $entityName, $typeName, $fields);

            $output = $this->option('output');

            if (is_string($output) && $output !== '') {
                $dir = dirname($output);
                if (!is_dir($dir)) {
                    mkdir($dir, 0755, true);
                }
                file_put_contents($output, $code);
                $this->info("✅  Generated {$typeName} → {$output}");
            } else {
                $this->line('');
                $this->line($code);
            }

            $this->info("Generated {$typeName} with " . count($fields) . ' field(s).');
            return self::SUCCESS;
        } catch (\Throwable $e) {
            $this->error('Failed to generate type: ' . $e->getMessage());
            return self::FAILURE;
        }
    }

    /**
     * Generate the PHP source code for a GraphQL Type class.
     *
     * @param string                        $entityClass Entity FQCN
     * @param string                        $entityName  Entity short name
     * @param string                        $typeName    Generated type class name
     * @param array<string, array<string, mixed>> $fields      Mapped fields
     *
     * @return string PHP source code
     */
    private function generateTypeClass(
        string $entityClass,
        string $entityName,
        string $typeName,
        array $fields,
    ): string {
        $reflection = new \ReflectionClass($entityClass);
        $entityNamespace = $reflection->getNamespaceName();

        $methods = [];
        foreach (array_keys($fields) as $fieldName) {
            $property = $reflection->hasProperty($fieldName)
                ? $reflection->getProperty($fieldName)
                : null;

            $phpType = 'mixed';
            if ($property !== null) {
                $type = $property->getType();
                if ($type instanceof \ReflectionNamedType) {
                    $phpType = $this->resolveReturnType($type);
                }
            }

            $methods[] = $this->generateFieldMethod($fieldName, $phpType, $entityName);
        }

        $methodBlock = implode("\n\n", $methods);
        $useEntity = $entityNamespace !== '' ? "use {$entityClass};" : '';

        return <<<PHP
        <?php declare(strict_types=1);

        namespace App\GraphQL\Type;

        use MonkeysLegion\GraphQL\Attribute\Type;
        use MonkeysLegion\GraphQL\Attribute\Field;
        {$useEntity}

        /**
         * GraphQL type for {$entityName} entity.
         *
         * Auto-generated by graphql:generate:type — feel free to customize.
         */
        #[Type(description: '{$entityName}')]
        final class {$typeName}
        {
        {$methodBlock}
        }

        PHP;
    }

    /**
     * Generate a single #[Field] method.
     *
     * @param string $fieldName  Property name
     * @param string $phpType    PHP return type
     * @param string $entityName Entity short name
     *
     * @return string PHP method source
     */
    private function generateFieldMethod(string $fieldName, string $phpType, string $entityName): string
    {
        $rootVar = lcfirst($entityName);
        $nullable = str_starts_with($phpType, '?') ? '?' : '';
        $cleanType = ltrim($phpType, '?');

        // Handle DateTimeInterface specially
        $returnExpr = match (true) {
            in_array($cleanType, [\DateTimeInterface::class, \DateTime::class, \DateTimeImmutable::class], true)
                => "\$root->{$fieldName}->format('c')",
            default => "\$root->{$fieldName}",
        };

        $returnType = match (true) {
            in_array($cleanType, [\DateTimeInterface::class, \DateTime::class, \DateTimeImmutable::class], true)
                => $nullable . 'string',
            default => $phpType,
        };

        return <<<PHP
            #[Field]
            public function {$fieldName}({$entityName} \$root): {$returnType}
            {
                return {$returnExpr};
            }
        PHP;
    }

    /**
     * Resolve a ReflectionNamedType to a PHP type string.
     *
     * @param \ReflectionNamedType $type The reflection type
     *
     * @return string The PHP type string
     */
    private function resolveReturnType(\ReflectionNamedType $type): string
    {
        $name = $type->getName();
        $prefix = $type->allowsNull() ? '?' : '';

        return match ($name) {
            'int', 'float', 'string', 'bool', 'array', 'mixed' => $prefix . $name,
            default => $prefix . '\\' . $name,
        };
    }
}
